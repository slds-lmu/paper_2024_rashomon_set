#' @title Base class for Objective Function
#'
#' @description
#' In our setup, an objective function contains both the actual objective function and the stream of samples.
#' This simulates the setting where we have a sampler over a parameter space and want to get the subset of samples that
#' fulfill some condition.
#'
#' Currently, `ObjectiveStreamActual` (generates random samples and independently evaluates them) and
#' `ObjectiveStreamRecorded` (uses a pre-recorded table of samples and their evaluations) are implemented.
#'
#' @details
#' This base class provides the actual API for objective streams, does checks, and records X values.
#'
#' Concrete classes must implement `private$.eval()` and `private$.sample()` and may override `private$.augmentTable()`.
#' @export
ObjectiveStream <- R6Class("ObjectiveStream",
  public = list(
    #' @description
    #' Initialize the objective function.
    #' @param id (`character(1)`) The id of the objective function, used to identify the objective when printing.
    #' @param domain (`ParamSet`) The domain of the objective function.
    #' @param minimize (`logical(1)`) Whether the objective function should be minimized.
    #' @param seed (`integer(2)`) Seed used both to initialize the sample stream (first element) and the evaluation
    #'   function (second element).
    initialize = function(id, domain, minimize, seed) {
      private$.id <- assertString(id)
      private$.domain <- assertClass(domain, "ParamSet")
      private$.minimize <- assertLogical(minimize)
      seeds <- assertIntegerish(seed, lower = 0, upper = .Machine$integer.max, any.missing = FALSE, len = 2, tol = 0)
      withLocalSeed(private$.seed.sample, set.seed(seeds[1]))
      withLocalSeed(private$.seed.eval, set.seed(seeds[2]))
    },
    #' @description
    #' Evaluate the objective function at a given point.
    #'
    #' Calls `private$.eval()` implemented by a concrete `ObjectiveStream` implementation.
    #' @param x (`data.frame`) The point at which to evaluate the objective function.
    #'   The concrete `ObjectiveStream` implementation can make the assumption that all rows were generated by
    #'   `$sample()`, though not necessarily in that order.
    #'   All domain columns as well as the `.id` column are required.
    #' @return (`numeric(nrow(x))`) The value of the objective function at the given point.
    eval = function(x) {
      assertDataFrame(x, min.rows = 1)
      required.cols <- c(self$domain$ids(), ".id")
      assertNames(colnames(x), must.include = required.cols)
      result <- withLocalSeed(private$.seed.eval, private$.eval(x[, ..required.cols, with = FALSE]))
      assertNumeric(result, finite = TRUE, len = nrow(x))
      result
    },
    #' @description
    #' Sample from the objective function.
    #'
    #' Calls `private$.sample()` implemented by a concrete `ObjectiveStream` implementation.
    #'
    #' The samples contain all columns of the domain, including an `.id` column of unique ids.
    #' Samples can be retrieved by their id using `$getRow()`.
    #' @param n (`integer(1)`) The number of samples to draw.
    #' @return (`data.frame`) A data.frame with the samples.
    sample = function(n = 1) {
      assertCount(n)
      if (n == 0) {
        table <- getNullTable(self$domain)
      } else {
        table <- withLocalSeed(private$.seed.sample, private$.sample(n))
        assertDataFrame(table, nrows = n)
        assertNames(colnames(table), must.include = self$domain$ids())
      }
      table <- table[, self$domain$ids(), with = FALSE]
      for (i in which(self$domain$is_categ)) {
        table[[i]] <- factor(table[[i]], levels = self$domain$levels[[i]])
      }
      private$.augmentTable(table)
    },
    #' @description
    #' Get a past sample from the sample stream.
    #' @param id (`integer(1)`) The id of the row to get.
    #' @return (`data.frame`) A data.frame with the row.
    getRow = function(id) {
      assertIntegerish(id, lower = 1, upper = nrow(private$.table), tol = 0)
      ret <- private$.table[id, self$domain$ids(), with = FALSE]
      set(ret, j = ".id", value = as.integer(id))
      ret
    }
  ),
  active = list(
    #' @field id (`character(1)`) The id of the objective function, used to identify the objective when printing.
    id = function() private$.id,
    #' @field domain (`ParamSet`) The domain of the objective function.
    domain = function() private$.domain,
    #' @field minimize (`logical(1)`) Whether the objective function should be minimized.
    minimize = function() private$.minimize
  ),
  private = list(
    .id = NULL,
    .domain = NULL,
    .minimize = NULL,
    .seed.sample = NULL,
    .seed.eval = NULL,
    .table = NULL,
    .augmentTable = function(table) {
      # Called by `sample()` to add an ID column to the table and record samples so that they can be retrieved by
      # their id using `$getRow()`.
      private$.table <- rbind(private$.table, table)
      set(table, j = ".id", value = seq.int(nrow(private$.table) - nrow(table) + 1, nrow(private$.table)))
      table
    },
    #' @description
    #' Abstract method to evaluate the objective function.
    #' @param x (`data.frame`) The points at which to evaluate the objective function.
    #'     Implementations can rely on the fact that columns `domain$ids()` and `.id` are present, in that order.
    #' @return (`numeric(nrow(x))`) The value of the objective function at the given point.
    .eval = function(x) {
      stop("Not implemented")
    },
    #' @description
    #' Abstract method to sample from the objective function.
    #' @param n (`integer(1)`) The number of samples to draw.
    #' @return (`data.frame`) A data.frame with the samples.
    .sample = function(n) {
      stop("Not implemented")
    }
  )
)
